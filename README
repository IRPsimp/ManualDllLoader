|-| This is a really old project which doesn't have any optimization that manually maps a DLL inside a x64 executable.

|-| This works by manually mapping the DLL along with its sections inside the remote process using WriteProcessMemory,
    fixing up the addresses by using the reloc section if it the DLL wasn't loaded at its preferred base,
    resolving the imports by getting each function in the IAT of the DLL and using GetProcAddress to get their correct address,
    Using section headers to restore correct page protection for the loaded sections in the Remote Process memory
    and finally creating a remote thread which calls the DLlentry with it's base address for execution

|-| The fact that this DLL is manually written to memory means that the DLL informations are not present inside
    the PEB.Ldr linked list

|-| DLL format
    \ Since this program uses CreateRemoteThread to execute the DLL entry point, we can only pass one parameter; So you would
        have to omit fdwReason for this to work, here is what the DLL should look like:

```
#include <windows.h>

BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,  // handle to DLL module
    DWORD fdwReason,     // reason for calling function
    LPVOID lpReserved)  // reserved
{
    MessageBoxA(0, "Hello World!", "Warning", MB_OK);
    return TRUE;
}
```

|-| Building
    \ To build the program run `nmake` in the home directory

|-| Notes
  \ this program does not check if DLL already loaded
  \ this program does not treat delay-loaded DLL's in the imports
  \ To use this program provide the DLL name and the pid of the remote process as remote arguments